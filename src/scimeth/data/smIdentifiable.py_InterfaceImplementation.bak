# -*- coding: utf-8 -*-
#
#File: smIdentifiable.py
#
"""
Created on Sun Mar 22 10:23:14 2020

Module ***smIdentifiable***

This module declares the interface ***smIdentifiable***




:Log:

+-------------+--------+------------------------------------------------------+
| Date        | Author | Description                                          |
+=============+========+======================================================+
| 22-Mar-2020 | FOE    | - Class created.                                     |
+-------------+--------+------------------------------------------------------+
| 29-Mar-2020 | FOE    | - Separated module comments from class comments.     |
+-------------+--------+------------------------------------------------------+
|  5-May-2020 | FOE    | - Added comment to clearly separate this ID from     |
|             |        |   from python built-in `id()`.                       |
+-------------+--------+------------------------------------------------------+
|  8-May-2020 | FOE    | - Improved comments further clarifying the           |
|             |        |   distinction between this ID and python built-in    |
|             |        |   `id()`.                                            |
+-------------+--------+------------------------------------------------------+


.. seealso:: None
.. note::
	
	The solution used here is inspired by that in:
	https://www.oreilly.com/library/view/c-cookbook/0596007612/ch08s09.html

	Another possibility that I considered was to force implementing
	classes to have a static factory rather than constructors, e.g.
	https://python-3-patterns-idioms-test.readthedocs.io/en/latest/Factory.html
	but at the time of taking the decision, the former seems a simpler
	option.


.. todo:: None

.. sectionauthor:: Felipe Orihuela-Espina <f.orihuela-espina@inaoep.mx>
.. codeauthor:: Felipe Orihuela-Espina <f.orihuela-espina@inaoep.mx>

"""


## Import
#import warnings
#import deprecation

#import os

from interface import Interface


#from scimeth import __version__
#from scimeth import data as scimeth


## Interface definition
class smIdentifiable(Interface):
	#Sphinx documentation
	"""Objects that are :class:`smIdentifiable <scimeth.data.smIdentifiable>`
	are constructred with an integer attribute :attr:`id`.
	
	Identifiable objects have a numerical ID under a unified interface. The
	used given to the numerical id depends on both the identifiable object
	itself, and perhaps a potential container class. Exemplary uses are:
	
	* A container class can use it as a kind of primary key, so that
	  within the container, the object id is unique among other instances.
	  Note that it is the container which must guarantee the uniqueness.
	* A relation of order can easily be established based on the `id`.
	
	When intended use is related to uniqueness, ID should be set upon object
	construction and (to facilitate uniqueness) it is recommended 
	not to be reset (for instance the property setter may constraint or
	fully fordib its resetting. To facilitate that instances of identifiable 
	objects do not share their `id`, and a class static `nextID` value
	may keep track of the next available ID for the object instances.
	
	.. warning::
		Although new objects are created with different ID but several
		objects of the same class may still have the same ID if they
		are generated by copying an existing objects rather than
		calling the constructor `__init__`. This is not a mistake
		but intended behaviour. But it means that classes holding
		a record of
		:class:`smIdentifiable <scimeth.data.smIdentifiable>` objects
		must still implement strategies to ensure uniqueness of ID
		if this is used as a primary key.
	
	:IMPORTANT Python's id() vs attribute id:
	
	Please note that this identifier **IS NOT** the
	object identifier as given by python built-in function `id()`.
	
	* The ID provided by this interface is meant to be a simple **mutable**,
	  so it can be reset if needed, whereas python's `id()` is immutable and
	  cannot be set.
	* The ID provided by this interface can be made **persistent**. This
	  distinction is critical; python's `id()` can change after dump/reloading
	  cycle from a persistent repository, e.g.
	  loaded from file-.). Because, the :attr:`id` attribute represented by
	  this interface is just a *regular* attribute, it can be made persistent
	  and hence guaranteed to not change when reloading from a persistent
	  repository. 
	* The ID provided by this interface can be given **semantics**, that is
	  the user decides the meaning of the id. Whereas
	  python's `id()` is somewhat arbitrary. For instance, in cases like CPython
	  it is related to the position in memory. 
	* Python's `id()` enforces **uniqueness** and is used by built-in types
	  such as sets. However, since as said, it is not persistent, this prevents any
	  potential use for a relation of total order. Instead, this ID, although
	  it gives some support for keeping uniqueness, but does not enforces it.
	  This means it can also be used for either total or partial orders.
	
	Note that there is no ambiguity or loss of functionality. Without
	this attribute, you can't call `<your_object>.id`.
	
	* To access Python's object unique identifier: `id(<your_object>)`
	* To access attribute :attr:`id`: `<your_object>.id`
	
	:Example:
	
	.. code-block:: python
	
		>>> a = 2
		>>> id(a)
		140736367534512
		>>> a.id
		Traceback (most recent call last):
		File "<ipython-input-32-6dc02a833f28>", line 1, in <module> a.id
		AttributeError: 'int' object has no attribute 'id'
	
	"""
	
	#Private class attributes shared by all instances
	#__nextID #A static member variable to keep track of the next
			   #available identifier to use. Note that this
			   #initialization is useless. Each instance, upon
			   #creation, will increment this value.
			   
		########################################################
		## NOTE: Attempting to convert this interface to a class
		## and used multiple inheritance, will imply that all
		## subclasses will share the same __nextID
		## Alternatively, it can be implemented as a dictionary
		## with one entry per subclass, whereby the subclass
		## gets registered upon calling the constructor of this
		## class.
		## Also, it may be convenient to consider an implementation
		## of type "mixin"; whereby this class is specailly
		## designed to work under multiple inheritnce.
		## See:
		## https://stackoverflow.com/questions/9575409/calling-parent-class-init-with-multiple-inheritance-whats-the-right-way
		## https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful
		## In python, attribute resolution in multiple inheritance
		## is performed depth-first and then from left to right amongst the
		## base classes -method resolution order (MRO).
		## (https://www.python-course.eu/python3_multiple_inheritance.php)
		## (https://help.semmle.com/wiki/display/PYTHON/Conflicting+attributes+in+base+classes)
		## Which means, it is recommended that the mixin base
		## class is declared earlier (as it is already prepared
		## to pass attributes when calling super() is resolving
		## which superclass constructor must be passed).
		## It also means that a third class inheriting from two smIdentifiable
		## classes will be solved correctly.
		########################################################
	
	#Properties getters/setters
	#
	# Remember: Sphinx ignores docstrings on property setters so all
	#documentation for a property must be on the @property method

	@property
	def id(self): #ID getter
		"""
		A unique numerical ID for the object instance.
		
		:getter: Gets the id.
		:setter: Sets the id.
		:type: int
		"""
		pass

	@id.setter
	def id(self,newId): #ID setter
		pass